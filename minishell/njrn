Pour réaliser un nouveau projet "minishell" en utilisant les fichiers que vous m'avez fournis, je vais créer une version simplifiée et refactorisée pour vous permettre de commencer un projet propre. Voici les grandes lignes du projet basé sur le code existant :

### 1. Structure du Projet
Je vais restructurer le projet en plusieurs fichiers clés, tout en réduisant la dépendance sur les variables globales. Le projet contiendra les fichiers suivants :

- **main.c** : Point d'entrée du shell.
- **builtin/éxécutables** : Chaque builtin aura son fichier propre (à partir de vos fichiers `ft_cd.c`, `ft_echo.c`, etc.).
- **executor.c** : Gère l'exécution des commandes.
- **parser.c** : Contient les fonctions de parsing pour analyser les commandes entrées par l'utilisateur.
- **signal.c** : Gère les signaux.
- **Makefile** : Fichier pour automatiser la compilation du projet.

### 2. Enlever les Variables Globales
Le code fourni utilise beaucoup de variables globales (ég. `g_cmd`, `g_shell`, `g_status`). Nous allons retirer les variables globales pour améliorer la portabilité et la lisibilité du code.

Nous allons encapsuler ces variables dans une structure `t_shell_state` que nous passerons aux fonctions concernées :

```c
typedef struct s_shell_state {
    t_cmd *cmd;
    t_shell shell;
    int status;
} t_shell_state;
```

Ensuite, chaque fonction utilisera un pointeur vers `t_shell_state` pour accéder à ces informations.

### 3. Fichier `main.c`
Le fichier `main.c` sera la base pour initialiser l'état du shell et lancer la boucle de réception de commandes.

```c
#include "minishell.h"

int main(int argc, char *argv[], char **envp) {
    t_shell_state state;
    char *input;

    // Initialisation de l'état du shell
    init_shell(&state, envp);

    // Boucle principale
    while (1) {
        input = readline("> ");
        if (!input) {
            printf("exit\n");
            break;
        }
        if (*input)
            add_history(input);
        // Parsing de la commande
        if (parsing(input, &state) == 0) {
            execute_command(&state);
        }
        free(input);
    }
    cleanup_shell(&state);
    return 0;
}
```

### 4. Module de Parsing (`parser.c`)
Le parsing a été réorganisé pour passer l'état du shell en paramètre, supprimant ainsi la dépendance sur des variables globales.

```c
#include "minishell.h"

int parsing(char *str, t_shell_state *state) {
    // Logique pour analyser la commande et créer la liste des commandes (tokens)
    // Utilisation de `state` au lieu de variables globales
    return 0;
}
```

### 5. Gestion des Builtins (`builtin/`)
Chaque commande builtin est contenue dans son propre fichier, par exemple `builtin/ft_cd.c` pour la commande `cd`.

Exemple pour `cd` :

```c
#include "minishell.h"

void ft_cd(t_cmd *cmd, t_shell_state *state) {
    char *path;

    if (!cmd->args[1]) {
        path = ft_getenv("HOME", state->envp);
        if (!path) {
            error_msg("cd", "HOME not set", 1);
            return;
        }
    } else {
        path = cmd->args[1];
    }
    if (chdir(path) != 0) {
        perror("cd");
    } else {
        update_pwd(state);
    }
}
```

### 6. Gestion de l'Exécution des Commandes (`executor.c`)
La fonction `execute_command` gère les commandes internes (builtins) et externes.

```c
#include "minishell.h"

void execute_command(t_shell_state *state) {
    t_cmd *cmd = state->cmd;

    if (is_builtin(cmd->args[0])) {
        execute_builtin(cmd, state);
    } else {
        pid_t pid = fork();
        if (pid == 0) {
            execve(cmd->args[0], cmd->args, state->envp);
            perror("execve");
            exit(EXIT_FAILURE);
        } else if (pid < 0) {
            perror("fork");
        } else {
            waitpid(pid, &state->status, 0);
        }
    }
}
```

### 7. Makefile
Un fichier Makefile de base pour compiler le projet :

```makefile
# Variables
NAME = minishell
CC = cc
CFLAGS = -Wall -Wextra -Werror
SRCS = main.c parser.c executor.c builtin/ft_cd.c builtin/ft_echo.c builtin/ft_env.c \
       builtin/ft_exit.c builtin/ft_export.c builtin/ft_pwd.c builtin/ft_unset.c signal.c
OBJS = $(SRCS:.c=.o)

# Règles
all: $(NAME)

$(NAME): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) -o $(NAME)

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
```

### Conclusion
Ce nouveau projet "minishell" est une version refactorisée du code que vous avez fourni. J'ai enlevé les variables globales en les remplaçant par une structure `t_shell_state` passée aux fonctions, et j'ai organisé le code pour qu'il soit plus modulaire et facile à maintenir.

